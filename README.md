# RPCCoroutineServiceFramework(基于协程服务框架的RPC版本)

## 项目概述
协程服务框架的RPC服务，是一个基于协程服务框架的注册中心，当然客户端和服务端的example我也有写。

rpc的体现在服务端和客户端的编写，这里由于多数是模拟，项目核心还是在注册中心，所以example多少写的有点不规范，较多内容可以以类的形式封装起来，后续改进

## 项目架构图

![image](https://github.com/huanheart/RPCCoroutineServiceFramework/blob/master/image/rpc.png)

## 运行环境要求

* 乌班图 22.04
* boost库（muduo库是基于boost库，固然需要有所依赖）
* muduo库（因为有用到异步日志）
* 有makefile , g++相关工具

## 启动
```cpp
sh ./build.sh
#若要手动启动,Client要最后启动,防止一开始出现问题(因为客户端代码中保证了一开始Client和注册中心建立了持久连接)
```
## 测试
在启动三个部分之后，可以发现客户端请求RPC会正确运行，我们需要模拟服务端在更改ip地址或端口因为异常关闭服务的时候，
对应客户端将会取消缓存重新定时查询当前服务的过程

```cpp
# 过滤查找出对应服务端的进程号,假设为3111
ps -aux |grep ./Server 
# 杀死对应服务端进程
kill -9 3111
#等待一会,可发现客户端将不会有服务端响应
#若此时启动服务,对应服务注册到注册中心上,此时客户端正常获取响应并输出
#但若此时先不启动服务,继续等待1分钟左右,可发现注册中心没有收到服务端的心跳,将其服务取消并输出对应取消的服务
#若此时才启动服务,对应服务注册到注册中心上,此时客户端正常获取响应并输出
```


## 待扩展部分
* 注册中心部分：
  - [X] 当客户端请求，返回对应服务ip以及端口地址
  - [X] 给予服务端注册功能
  - [X] 利用时间戳机制，定时查询服务端是否有发送心跳，确定服务的可用性
* 客户端部分(本质上也是个服务器,这里模拟当前服务器需要远程调用其他服务器的方法)
  - [X] 客户端调用服务端的时候像本地方法一样
  - [X] 完成有关通道类，控制器类等的代码编写
  - [X] 通过判定控制器的状态，决定是否将Serviceport以及Serviceip清除(模拟客户端清除缓存以及本地缓存的过程)
* 服务端部分
  - [X] 定时心跳机制，将自己的服务发送到注册中心，保证服务的可用性
  - [X] 利用**桥接模式**，实现provider类，将服务端的监听请求模块和服务本身进行一个解耦
  - [X] 实现简单的RPC服务,反馈客户端的本地方法

-[ ] 改进example的不规范部分



